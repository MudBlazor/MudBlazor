@namespace MudBlazor
@inherits MudComponentBase
@using MudBlazor.Utilities
@implements IAsyncDisposable

@if (TabContent == null && TabWrapperContent == null)
{
    <MudTooltip Placement="@GetTooltipPlacement()" Text="@ToolTip">
        @_renderTabHeader
    </MudTooltip>
}
else
{
    <div class="d-inline-block" style="width: fit-content;">
        @(TabWrapperContent?.Invoke(_renderTabHeader) ?? _renderTabHeader)
    </div>
}

@code {

    private Boolean _disposed;

    [CascadingParameter] private MudTabs Parent { get; set; }

    public ElementReference PanelRef;

    private RenderFragment _renderTabHeader;

    /// <summary>
    /// Text will be displayed in the TabPanel as TabTitle. Text is no longer rendered
    /// as a MarkupString, so use the TabContent RenderFragment instead for HTML content.
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public string Text { get; set; }

    /// <summary>
    /// Icon placed before the text if set.
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public string Icon { get; set; }

    /// <summary>
    /// If true, the tabpanel will be disabled.
    /// </summary>
    [Parameter]
    [Category(CategoryTypes.Tabs.Behavior)]
    public bool Disabled { get; set; }

    /// <summary>
    /// MudDynamicTabs: If true, shows the close icon in the TabPanel.
    /// </summary>
    [Parameter]
    [Category(CategoryTypes.Tabs.Behavior)]
    public bool ShowCloseIcon { get; set; } = true;

    /// <summary>
    /// Optional information to be showed into a badge
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public object BadgeData { get; set; }

    /// <summary>
    /// Optional information to show the badge as a dot.
    /// </summary>
    [Parameter]
    [Category(CategoryTypes.Tabs.Behavior)]
    public bool BadgeDot { get; set; }

    /// <summary>
    /// The color of the badge.
    /// </summary>
    [Parameter]
    [Category(CategoryTypes.Tabs.Appearance)]
    public Color BadgeColor { get; set; } = Color.Primary;

    /// <summary>
    /// Unique TabPanel ID. Useful for activation when Panels are dynamically generated.
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public object ID { get; set; }

    /// <summary>
    /// Raised when tab is clicked
    /// </summary>
    [Parameter] public EventCallback<MouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Child content of component.
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public RenderFragment ChildContent { get; set; }

    /// <summary>
    /// Tab content of component.
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public RenderFragment TabContent { get; set; }

    /// <summary>
    /// Tab content wrapper of component. It is used to wrap the content of a tab heading in a user supplied div or component. 
    /// Use @context in the TabWrapperContent to render the tab header within your custom wrapper. 
    /// This is most useful with tooltips, which must wrap the entire content they refer to.
    /// </summary>
    [Parameter] 
    [Category(CategoryTypes.Tabs.Behavior)]
    public RenderFragment<RenderFragment> TabWrapperContent { get; set; }

    /// <summary>
    /// TabPanel Tooltip. It will be ignored if TabContent is provided.
    /// </summary>
    [Parameter]
    [Category(CategoryTypes.Tabs.Behavior)]
    public string ToolTip { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if(firstRender == true && Parent != null)
        {
            await Parent.SetPanelRef(PanelRef);
        }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        if (Parent is null)
            // NOTE: we must not throw here because we need the component to be able to live for the API docs to be able to infer default values
            return;

        Parent.AddPanel(this);
        _renderTabHeader =
            @<div @ref="PanelRef" @attributes="UserAttributes" class="@GetTabClass()" style="@GetTabStyle()" @onclick="@(e => Parent.ActivatePanel(this, e, false))">
                @if (Parent.TabPanelHeaderPosition == TabHeaderPosition.Before && Parent.TabPanelHeader != null)
                {
                    <div class="mud-tabs-panel-header mud-tabs-panel-header-before">
                        @Parent.TabPanelHeader(this)
                    </div>
                }
                @if (TabContent != null)
                {
                    @TabContent
                }
                else if (!String.IsNullOrEmpty(Text) && String.IsNullOrEmpty(Icon))
                {
                    @Text
                }
                else if (String.IsNullOrEmpty(Text) && !String.IsNullOrEmpty(Icon))
                {
                    <MudIcon Icon="@Icon" Color="@Parent.IconColor" />
                }
                else if (!String.IsNullOrEmpty(Text) && !String.IsNullOrEmpty(Icon))
                {
                    <MudIcon Icon="@Icon" Color="@Parent.IconColor" Class="mud-tab-icon-text" />
                    @Text
                }
                @if (BadgeData != null || BadgeDot)
                {
                    <MudBadge Dot="@BadgeDot" Content="@BadgeData" Color="@BadgeColor" Class="mud-tab-badge" />
                }
                @if (Parent.TabPanelHeaderPosition == TabHeaderPosition.After && Parent.TabPanelHeader != null)
                {
                    <div class="mud-tabs-panel-header mud-tabs-panel-header-after">
                        @Parent.TabPanelHeader(this)
                    </div>
                }
            </div>;
    }

    private Placement GetTooltipPlacement()
        => Parent?.Position switch
        {
            Position.Right  => Placement.Left,
            Position.Left   => Placement.Right,
            Position.Bottom => Placement.Top,
            Position.Top    => Placement.Bottom,
            Position.Center => Placement.Bottom,
            Position.Start  => Placement.End,
            Position.End    => Placement.Start,
            // For the API docs, we need to accept not having a parent
            null            => Placement.Bottom,
            _               => throw new ArgumentOutOfRangeException()
        };

    private string GetTabClass()
    {
        var tabClass = new CssBuilder("mud-tab")
            .AddClass("mud-tab-active", when: () => this == Parent.ActivePanel)
            .AddClass("mud-disabled", Disabled)
            .AddClass("mud-ripple", !Parent.DisableRipple)
            .AddClass(Parent.TabPanelClass)
            .AddClass(Class)
            .Build();

        return tabClass;
    }

    private string GetTabStyle()
    {
        var tabStyle = new StyleBuilder()
            .AddStyle("min-width", Parent.MinimumTabWidth)
            .AddStyle(Style)
            .Build();

        return tabStyle;
    }

    public async ValueTask DisposeAsync()
    {
        if(_disposed == true) { return;  }

        _disposed = true;
        if (Parent is not null)
            await Parent.RemovePanel(this);
    }
}
